# 1_Dashboard_Geral.py - P√°gina Principal do Dashboard HP Anti-Fraude

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from utils import load_data, load_ml_scores, get_risk_categories, get_seller_metrics, get_community_metrics, get_logo_path

# --- CONFIGURA√á√ÉO DA P√ÅGINA ---
st.set_page_config(
    page_title="HP Anti-Fraude | Dashboard Geral",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- CARREGAMENTO DOS DADOS ---
PATH_DATASET = "data/final_grafo/dataset_final_com_grafo.csv"
df = load_data(PATH_DATASET)
df_with_scores = load_ml_scores()

# Adicionar categorias de risco
df = get_risk_categories(df)

# --- T√çTULO E INTRODU√á√ÉO ---
st.title("üõ°Ô∏è Dashboard Estrat√©gico Anti-Fraude HP")
st.markdown("""
**Vis√£o geral do ecossistema de an√∫ncios e detec√ß√£o de atividades suspeitas no Mercado Livre.**
Este dashboard apresenta an√°lises em tempo real para identifica√ß√£o proativa de fraudes em cartuchos HP.
""")

if df is None:
    st.stop()

# --- M√âTRICAS DE VOLUME E ABRANG√äNCIA ---
st.header("üìä Panorama Geral")

# Calcular m√©tricas principais
total_anuncios = len(df)
anuncios_suspeitos = df['is_fraud_suspect_v2'].sum()
vendedores_unicos = df['seller_id'].nunique()
vendedores_suspeitos = df[df['is_fraud_suspect_v2'] == 1]['seller_id'].nunique()

# Volume financeiro em risco
if 'preco_atual' in df.columns:
    volume_financeiro_risco = df[df['is_fraud_suspect_v2'] == 1]['preco_atual'].sum()
else:
    volume_financeiro_risco = 0

# Taxa de detec√ß√£o
taxa_deteccao = (anuncios_suspeitos / total_anuncios * 100) if total_anuncios > 0 else 0

# Layout das m√©tricas
col1, col2, col3, col4, col5 = st.columns(5)

with col1:
    st.metric(
        label="An√∫ncios Analisados", 
        value=f"{total_anuncios:,}",
        delta=f"Base total"
    )

with col2:
    st.metric(
        label="An√∫ncios Suspeitos", 
        value=f"{anuncios_suspeitos:,}",
        delta=f"{taxa_deteccao:.1f}% do total"
    )

with col3:
    st.metric(
        label="Vendedores Suspeitos", 
        value=f"{vendedores_suspeitos:,}",
        delta=f"{vendedores_suspeitos/vendedores_unicos*100:.1f}% dos vendedores"
    )

with col4:
    st.metric(
        label="Valor em Risco", 
        value=f"R$ {volume_financeiro_risco:,.0f}",
        delta=f"R$ {volume_financeiro_risco/total_anuncios:,.0f} por an√∫ncio"
    )

with col5:
    st.metric(
        label="Taxa de Detec√ß√£o", 
        value=f"{taxa_deteccao:.1f}%",
        delta="Efici√™ncia do sistema"
    )

# --- AN√ÅLISE DE RISCOS POR CATEGORIA ---
st.header("üéØ An√°lise de Riscos por Categoria")

col1, col2 = st.columns(2)

with col1:
    # Distribui√ß√£o por categoria de risco
    risk_dist = df['risk_category'].value_counts()
    
    fig_risk = px.pie(
        values=risk_dist.values, 
        names=risk_dist.index,
        title="Distribui√ß√£o por N√≠vel de Risco",
        color_discrete_sequence=px.colors.qualitative.Set2
    )
    fig_risk.update_traces(textposition='inside', textinfo='percent+label')
    st.plotly_chart(fig_risk, use_container_width=True, config={'displayModeBar': False})

with col2:
    # Score m√©dio por categoria
    score_by_risk = df.groupby('risk_category', observed=True)['score_de_suspeita'].mean().sort_values(ascending=False)
    
    fig_score = px.bar(
        x=score_by_risk.index, 
        y=score_by_risk.values,
        title="Score M√©dio por Categoria de Risco",
        labels={'x': 'Categoria de Risco', 'y': 'Score M√©dio'},
        color=score_by_risk.values,
        color_continuous_scale='Reds'
    )
    fig_score.update_layout(showlegend=False)
    st.plotly_chart(fig_score, use_container_width=True, config={'displayModeBar': False})

# --- AN√ÅLISE DOS SINAIS DE FRAUDE ---
st.header("üîç An√°lise dos Sinais de Fraude")

col1, col2 = st.columns(2)

with col1:
    # Distribui√ß√£o do Score de Suspeita
    st.subheader("Distribui√ß√£o do Score de Suspeita")
    fig_hist = px.histogram(
        df, 
        x="score_de_suspeita", 
        nbins=20, 
        title="Frequ√™ncia dos Scores de Risco",
        color_discrete_sequence=['#FF6B35']
    )
    fig_hist.update_layout(
        yaxis_title="N¬∫ de An√∫ncios",
        xaxis_title="Score de Suspeita"
    )
    fig_hist.add_vline(x=3, line_dash="dash", line_color="red", annotation_text="Threshold")
    st.plotly_chart(fig_hist, use_container_width=True, config={'displayModeBar': False})

with col2:
    # Fatores de Risco Mais Comuns
    st.subheader("Fatores de Risco Mais Comuns")
    flags = [col for col in df.columns if col.startswith('flag_')]
    if flags:
        flags_counts = df[flags].sum().sort_values(ascending=False)
        df_flags = pd.DataFrame(flags_counts, columns=['Ocorr√™ncias']).reset_index().rename(columns={'index': 'Fator de Risco'})
        
        fig_bar = px.bar(
            df_flags.head(7), 
            x='Ocorr√™ncias', 
            y='Fator de Risco', 
            orientation='h', 
            title="Top 7 Sinais de Alerta",
            color='Ocorr√™ncias',
            color_continuous_scale='Reds'
        )
        fig_bar.update_layout(yaxis={'categoryorder':'total ascending'})
        st.plotly_chart(fig_bar, use_container_width=True, config={'displayModeBar': False})
    else:
        st.info("Flags de fraude n√£o encontradas no dataset atual.")

# --- AN√ÅLISE DE PRE√áOS ---
if 'diferenca_preco_perc' in df.columns and 'preco_atual' in df.columns:
    st.header("üí∞ An√°lise de Pre√ßos e Suspeita")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Rela√ß√£o entre Pre√ßo e Suspeita
        st.subheader("Rela√ß√£o entre Pre√ßo e Suspeita de Fraude")
        fig_scatter = px.scatter(
            df, 
            x='diferenca_preco_perc', 
            y='score_de_suspeita',
            color=df['is_fraud_suspect_v2'].map({0: 'Leg√≠timo', 1: 'Suspeito'}),
            color_discrete_map={'Leg√≠timo': 'blue', 'Suspeito': 'red'},
            hover_data=['vendedor_nome', 'preco_atual'],
            title="Score de Suspeita vs. Desconto sobre o Pre√ßo Sugerido"
        )
        fig_scatter.update_layout(
            xaxis_title="Diferen√ßa Percentual de Pre√ßo",
            yaxis_title="Score de Suspeita",
            xaxis_tickformat=".0%"
        )
        st.plotly_chart(fig_scatter, use_container_width=True, config={'displayModeBar': False})
    
    with col2:
        # Distribui√ß√£o de Pre√ßos por Status
        st.subheader("Distribui√ß√£o de Pre√ßos por Status")
        fig_box = px.box(
            df, 
            x='is_fraud_suspect_v2', 
            y='preco_atual',
            color='is_fraud_suspect_v2',
            color_discrete_map={0: 'blue', 1: 'red'},
            title="Distribui√ß√£o de Pre√ßos: Leg√≠timo vs Suspeito",
            labels={'is_fraud_suspect_v2': 'Status', 'preco_atual': 'Pre√ßo (R$)'}
        )
        fig_box.update_layout(showlegend=False)
        st.plotly_chart(fig_box, use_container_width=True, config={'displayModeBar': False})

# --- AN√ÅLISE DE VENDEDORES ---
st.header("üë• An√°lise de Vendedores")

# Top vendedores suspeitos
seller_metrics = get_seller_metrics(df)
top_sellers = seller_metrics.head(10)

st.subheader("Top 10 Vendedores com Mais An√∫ncios Suspeitos")
st.dataframe(
    top_sellers[['vendedor_nome', 'total_anuncios', 'anuncios_suspeitos', 'taxa_suspeita', 'score_medio', 'status']],
    use_container_width=True,
    column_config={
        "vendedor_nome": "Vendedor",
        "total_anuncios": "Total An√∫ncios",
        "anuncios_suspeitos": "An√∫ncios Suspeitos",
        "taxa_suspeita": st.column_config.ProgressColumn("Taxa Suspeita", format="%.1f%%", min_value=0, max_value=100),
        "score_medio": st.column_config.NumberColumn("Score M√©dio", format="%.2f"),
        "status": "Status"
    }
)

# --- AN√ÅLISE COM MACHINE LEARNING (se dispon√≠vel) ---
if df_with_scores is not None:
    st.header("ü§ñ An√°lise com Machine Learning & Score H√≠brido")
    
    # Verificar se a coluna score_hibrido existe
    has_hybrid_score = 'score_hibrido' in df_with_scores.columns
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Distribui√ß√£o dos Scores ML")
        fig_ml_hist = px.histogram(
            df_with_scores, 
            x='ml_score', 
            nbins=30,
            title="Distribui√ß√£o do ML Score",
            color_discrete_sequence=['#2E8B57']
        )
        fig_ml_hist.add_vline(x=0.5, line_dash="dash", line_color="red", annotation_text="Threshold ML")
        st.plotly_chart(fig_ml_hist, use_container_width=True, config={'displayModeBar': False})
    
    with col2:
        if has_hybrid_score:
            st.subheader("Distribui√ß√£o do Score H√≠brido")
            fig_hybrid_hist = px.histogram(
                df_with_scores, 
                x='score_hibrido', 
                nbins=30,
                title="Distribui√ß√£o do Score H√≠brido (Heur√≠stica + ML)",
                color_discrete_sequence=['#FF6B35']
            )
            fig_hybrid_hist.add_vline(x=df_with_scores['score_hibrido'].median(), line_dash="dash", line_color="blue", annotation_text="Mediana")
            st.plotly_chart(fig_hybrid_hist, use_container_width=True, config={'displayModeBar': False})
        else:
            st.subheader("ML Score vs Heur√≠stica")
            fig_scatter = px.scatter(
                df_with_scores, 
                x='score_de_suspeita', 
                y='ml_score',
                color='is_fraud_suspect_v2',
                color_discrete_map={0: 'blue', 1: 'red'},
                title="Heur√≠stica vs ML Score",
                labels={'score_de_suspeita': 'Score Heur√≠stica', 'ml_score': 'ML Score'}
            )
            fig_scatter.add_hline(y=0.5, line_dash="dash", line_color="red")
            fig_scatter.add_vline(x=3, line_dash="dash", line_color="blue")
            st.plotly_chart(fig_scatter, use_container_width=True, config={'displayModeBar': False})
    
    # Nova se√ß√£o: Compara√ß√£o dos 3 scores
    if has_hybrid_score:
        st.subheader("üìä Compara√ß√£o: Heur√≠stica vs ML vs H√≠brido")
        
        col_a, col_b = st.columns(2)
        
        with col_a:
            # Scatter plot: Heur√≠stica vs ML Score
            fig_comparison = px.scatter(
                df_with_scores, 
                x='score_de_suspeita', 
                y='ml_score',
                color='is_fraud_suspect_v2',
                color_discrete_map={0: 'blue', 1: 'red'},
                title="Heur√≠stica vs ML Score",
                labels={'score_de_suspeita': 'Score Heur√≠stica', 'ml_score': 'ML Score'},
                hover_data=['score_hibrido']
            )
            fig_comparison.add_hline(y=0.5, line_dash="dash", line_color="red", annotation_text="Threshold ML")
            fig_comparison.add_vline(x=3, line_dash="dash", line_color="blue", annotation_text="Threshold Heur√≠stica")
            st.plotly_chart(fig_comparison, use_container_width=True, config={'displayModeBar': False})
        
        with col_b:
            # Scatter plot: Score H√≠brido vs Heur√≠stica
            fig_hybrid_comp = px.scatter(
                df_with_scores, 
                x='score_de_suspeita', 
                y='score_hibrido',
                color='is_fraud_suspect_v2',
                color_discrete_map={0: 'green', 1: 'orange'},
                title="Score H√≠brido vs Heur√≠stica",
                labels={'score_de_suspeita': 'Score Heur√≠stica', 'score_hibrido': 'Score H√≠brido'},
                hover_data=['ml_score']
            )
            fig_hybrid_comp.add_vline(x=3, line_dash="dash", line_color="blue", annotation_text="Threshold Heur√≠stica")
            st.plotly_chart(fig_hybrid_comp, use_container_width=True, config={'displayModeBar': False})
        
        # Estat√≠sticas dos scores
        st.subheader("üìà Estat√≠sticas Comparativas")
        col_stat1, col_stat2, col_stat3 = st.columns(3)
        
        with col_stat1:
            st.metric(
                "M√©dia Score Heur√≠stica", 
                f"{df_with_scores['score_de_suspeita'].mean():.2f}",
                f"Desvio: {df_with_scores['score_de_suspeita'].std():.2f}"
            )
        
        with col_stat2:
            st.metric(
                "M√©dia ML Score", 
                f"{df_with_scores['ml_score'].mean():.3f}",
                f"Desvio: {df_with_scores['ml_score'].std():.3f}"
            )
        
        with col_stat3:
            st.metric(
                "M√©dia Score H√≠brido", 
                f"{df_with_scores['score_hibrido'].mean():.3f}",
                f"Desvio: {df_with_scores['score_hibrido'].std():.3f}"
            )
        
        # Tabela com top an√∫ncios por score h√≠brido
        st.subheader("üéØ Top 20 An√∫ncios por Score H√≠brido")
        top_hybrid = df_with_scores.nlargest(20, 'score_hibrido')[
            ['id_anuncio', 'vendedor_nome', 'score_de_suspeita', 'ml_score', 'score_hibrido', 'is_fraud_suspect_v2', 'preco_atual', 'link_anuncio']
        ].copy()
        
        # Adicionar coluna de classifica√ß√£o
        top_hybrid['classificacao'] = top_hybrid['is_fraud_suspect_v2'].map({0: 'Leg√≠timo', 1: 'Suspeito'})
        
        st.dataframe(
            top_hybrid[['id_anuncio', 'vendedor_nome', 'score_de_suspeita', 'ml_score', 'score_hibrido', 'classificacao', 'preco_atual', 'link_anuncio']],
            use_container_width=True,
            column_config={
                "id_anuncio": "ID An√∫ncio",
                "vendedor_nome": "Vendedor",
                "score_de_suspeita": st.column_config.NumberColumn("Score Heur√≠stica", format="%.2f"),
                "ml_score": st.column_config.NumberColumn("ML Score", format="%.4f"),
                "score_hibrido": st.column_config.NumberColumn("Score H√≠brido", format="%.4f", help="Combina√ß√£o ponderada de Heur√≠stica + ML"),
                "classificacao": "Classifica√ß√£o",
                "preco_atual": st.column_config.NumberColumn("Pre√ßo (R$)", format="R$ %.2f"),
                "link_anuncio": st.column_config.LinkColumn("Link", display_text="Abrir", width="small")
            },
            hide_index=True,
            height=400
        )
        
        # Info sobre o c√°lculo do score h√≠brido
        with st.expander("‚ÑπÔ∏è Como √© calculado o Score H√≠brido?"):
            st.markdown("""
            **Score H√≠brido** √© uma combina√ß√£o ponderada do Score Heur√≠stico e do ML Score:
            
            - **Score Heur√≠stico**: Baseado em regras de neg√≥cio e flags de fraude (50%)
            - **ML Score**: Predi√ß√£o do modelo de Machine Learning (50%)
            
            F√≥rmula:
            ```
            score_hibrido = (score_de_suspeita_normalizado * 0.5) + (ml_score * 0.5)
            ```
            
            Onde:
            - `score_de_suspeita_normalizado` = score_de_suspeita / 10 (normalizado para 0-1)
            - `ml_score` = probabilidade do modelo (j√° est√° em 0-1)
            
            **Vantagens do Score H√≠brido:**
            - Combina conhecimento especialista (heur√≠stica) com aprendizado de padr√µes (ML)
            - Reduz falsos positivos e falsos negativos
            - Mais robusto que usar apenas um m√©todo
            """)
        
        # Se√ß√£o de Thresholds Configur√°veis
        st.subheader("‚öôÔ∏è Configura√ß√£o de Thresholds")
        col_thresh1, col_thresh2, col_thresh3 = st.columns(3)
        
        with col_thresh1:
            threshold_heuristica = st.slider(
                "Threshold Heur√≠stica:",
                min_value=0.0,
                max_value=10.0,
                value=3.0,
                step=0.5,
                help="Score m√≠nimo para considerar suspeito via heur√≠stica"
            )
        
        with col_thresh2:
            threshold_ml = st.slider(
                "Threshold ML:",
                min_value=0.0,
                max_value=1.0,
                value=0.5,
                step=0.05,
                help="Probabilidade m√≠nima para considerar suspeito via ML"
            )
        
        with col_thresh3:
            threshold_hibrido = st.slider(
                "Threshold H√≠brido:",
                min_value=0.0,
                max_value=1.0,
                value=0.3,
                step=0.05,
                help="Score h√≠brido m√≠nimo para considerar suspeito"
            )
        
        # Aplicar thresholds aos gr√°ficos
        st.subheader("üìä An√°lise com Thresholds Configurados")
        
        col_vis1, col_vis2 = st.columns(2)
        
        with col_vis1:
            # Gr√°fico com thresholds aplicados
            fig_thresholds = px.scatter(
                df_with_scores, 
                x='score_de_suspeita', 
                y='ml_score',
                color='is_fraud_suspect_v2',
                color_discrete_map={0: 'blue', 1: 'red'},
                title=f"An√°lise com Thresholds (H:{threshold_heuristica}, ML:{threshold_ml})",
                labels={'score_de_suspeita': 'Score Heur√≠stica', 'ml_score': 'ML Score'}
            )
            fig_thresholds.add_hline(y=threshold_ml, line_dash="dash", line_color="red", annotation_text=f"ML: {threshold_ml}")
            fig_thresholds.add_vline(x=threshold_heuristica, line_dash="dash", line_color="blue", annotation_text=f"Heur√≠stica: {threshold_heuristica}")
            st.plotly_chart(fig_thresholds, use_container_width=True, config={'displayModeBar': False})
        
        with col_vis2:
            # Distribui√ß√£o do score h√≠brido com threshold
            fig_hybrid_thresh = px.histogram(
                df_with_scores, 
                x='score_hibrido', 
                nbins=30,
                title=f"Distribui√ß√£o Score H√≠brido (Threshold: {threshold_hibrido})",
                color_discrete_sequence=['#FF6B35']
            )
            fig_hybrid_thresh.add_vline(x=threshold_hibrido, line_dash="dash", line_color="red", annotation_text=f"Threshold: {threshold_hibrido}")
            st.plotly_chart(fig_hybrid_thresh, use_container_width=True, config={'displayModeBar': False})
        
        # Estat√≠sticas com thresholds aplicados
        anuncios_heuristica = (df_with_scores['score_de_suspeita'] >= threshold_heuristica).sum()
        anuncios_ml = (df_with_scores['ml_score'] >= threshold_ml).sum()
        anuncios_hibrido = (df_with_scores['score_hibrido'] >= threshold_hibrido).sum()
        
        col_stat1, col_stat2, col_stat3 = st.columns(3)
        with col_stat1:
            st.metric("An√∫ncios Heur√≠stica", f"{anuncios_heuristica}", f"{anuncios_heuristica/len(df_with_scores)*100:.1f}%")
        with col_stat2:
            st.metric("An√∫ncios ML", f"{anuncios_ml}", f"{anuncios_ml/len(df_with_scores)*100:.1f}%")
        with col_stat3:
            st.metric("An√∫ncios H√≠brido", f"{anuncios_hibrido}", f"{anuncios_hibrido/len(df_with_scores)*100:.1f}%")
        
        # Explica√ß√£o do Score Heur√≠stico
        with st.expander("üîç Como √© calculado o Score Heur√≠stico?"):
            st.markdown("""
            **Score Heur√≠stico** √© baseado em regras de neg√≥cio e flags de fraude:
            
            **Flags de Fraude (peso 1.0 cada):**
            - `flag_fraude_instantanea`: Detec√ß√£o imediata de fraude
            - `flag_preco_muito_baixo`: Pre√ßo suspeitamente baixo
            - `flag_vendedor_novo`: Vendedor com pouca experi√™ncia
            - `flag_imagem_muito_reutilizada`: Reutiliza√ß√£o excessiva de imagens
            - `flag_reputacao_muito_ruim`: Reputa√ß√£o muito baixa
            - `flag_reviews_muito_negativas`: Reviews muito negativas
            - `flag_loja_oficial_suspeita`: Loja oficial com comportamento suspeito
            
            **Flags de Pre√ßo (peso 0.5 cada):**
            - `flag_preco_medio_baixo`: Pre√ßo m√©dio-baixo
            - `flag_preco_ligeiramente_baixo`: Pre√ßo ligeiramente baixo
            
            **Flags de Reputa√ß√£o (peso 0.3 cada):**
            - `flag_reputacao_ruim`: Reputa√ß√£o ruim
            - `flag_reviews_negativas`: Reviews negativas
            
            **Flags de Imagem (peso 0.2 cada):**
            - `flag_imagem_reutilizada`: Reutiliza√ß√£o moderada de imagens
            
            **F√≥rmula:**
            ```
            score_de_suspeita = Œ£(flag_fraude * 1.0) + Œ£(flag_preco * 0.5) + 
                               Œ£(flag_reputacao * 0.3) + Œ£(flag_imagem * 0.2)
            ```
            
            **Vantagens:**
            - Baseado em conhecimento especialista
            - Interpret√°vel e explic√°vel
            - Captura padr√µes conhecidos de fraude
            """)
        
        # Feature Importance do ML
        with st.expander("ü§ñ Feature Importance do Modelo ML (sem pre√ßo)"):
            try:
                # Carregar feature importance
                feature_importance = pd.read_csv("data/features/feature_importance_ridge_classifier.csv")
                
                # Top 15 features mais importantes (por valor absoluto)
                top_features = feature_importance.head(15)
                
                # Criar gr√°fico com valores positivos e negativos
                fig_importance = px.bar(
                    top_features,
                    x='Coefficient',
                    y='Feature',
                    orientation='h',
                    title="Top 15 Features Mais Importantes (Ridge Classifier)",
                    color='Coefficient',
                    color_continuous_scale='RdBu_r',  # Escala que vai do vermelho ao azul
                    range_color=[-max(abs(top_features['Coefficient'])), max(abs(top_features['Coefficient']))]
                )
                fig_importance.update_layout(
                    yaxis={'categoryorder':'total ascending'},
                    xaxis_title="Coeficiente (Positivo = Aumenta Fraude, Negativo = Diminui Fraude)"
                )
                # Adicionar linha vertical em x=0
                fig_importance.add_vline(x=0, line_dash="dash", line_color="black", annotation_text="Neutro")
                st.plotly_chart(fig_importance, use_container_width=True, config={'displayModeBar': False})
                
                # Tabela com valores exatos dos coeficientes
                st.subheader("üìä Valores Exatos dos Coeficientes")
                top_features_display = top_features[['Feature', 'Coefficient', 'Abs_Coefficient']].copy()
                top_features_display['Efeito'] = top_features_display['Coefficient'].apply(
                    lambda x: 'üî¥ Aumenta Fraude' if x > 0 else 'üîµ Diminui Fraude' if x < 0 else '‚ö™ Neutro'
                )
                top_features_display['Coeficiente'] = top_features_display['Coefficient'].round(4)
                top_features_display['Import√¢ncia'] = top_features_display['Abs_Coefficient'].round(4)
                
                st.dataframe(
                    top_features_display[['Feature', 'Coeficiente', 'Efeito', 'Import√¢ncia']],
                    use_container_width=True,
                    hide_index=True
                )
                
                st.markdown("""
                **Interpreta√ß√£o dos Coeficientes:**
                - **üî¥ Valores Positivos**: Aumentam a probabilidade de fraude
                - **üîµ Valores Negativos**: Diminuem a probabilidade de fraude
                - **Import√¢ncia**: Valor absoluto do coeficiente (quanto maior, mais importante)
                
                **An√°lise das Top Features:**
                - **flag_fraude_instantanea**: Flag de detec√ß√£o imediata (maior impacto positivo)
                - **grafo_taxa_suspeita_vendedor**: Taxa de suspeita do vendedor no grafo
                - **grafo_pagerank**: Centralidade do vendedor na rede (pode ser negativo se vendedores centrais s√£o confi√°veis)
                - **grafo_peso_medio_conexoes**: Peso m√©dio das conex√µes
                - **grafo_closeness**: Proximidade na rede de vendedores
                """)
                
            except FileNotFoundError:
                st.warning("Arquivo de feature importance n√£o encontrado.")
        
        # Explica√ß√£o do Grafo
        with st.expander("üï∏Ô∏è Como foi constru√≠do o Grafo de Fraude?"):
            st.markdown("""
            ### **Constru√ß√£o do Grafo de Vendedores:**
            
            Para entender as rela√ß√µes ocultas entre os vendedores, constru√≠mos uma rede social (grafo) que nos permite aplicar an√°lises de rede avan√ßadas.
            
            **1. N√≥s (Vendedores):**
            - Cada vendedor (`seller_id`) √© um ponto (n√≥) no nosso mapa da rede
            - Cada n√≥ carrega atributos importantes, como sua reputa√ß√£o, volume de vendas e o `score_de_suspeita` que calculamos anteriormente
            
            **2. Arestas (Conex√µes Ponderadas):**
            - As conex√µes entre os vendedores s√£o criadas com base em evid√™ncias concretas, e cada tipo de evid√™ncia tem um peso diferente que reflete a for√ßa do la√ßo:
              - **Conex√£o Forte (Peso 5.0):** Vendedores que anunciam o mesmo produto de cat√°logo oficial (`catalog_product_id`)
              - **Conex√£o M√©dia (Peso 2.0):** Vendedores que a plataforma sugere como alternativas de compra
              - **Conex√£o Contextual (Peso 1.0):** Vendedores que usam a mesma imagem de produto
              - **Conex√£o Sem√¢ntica (Peso 0.5):** Vendedores cujos textos de an√∫ncio s√£o muito similares em significado
            
            **3. Algoritmos Utilizados e Features Geradas:**
            
            Uma vez que o mapa da rede est√° constru√≠do, aplicamos algoritmos consagrados da teoria dos grafos para extrair intelig√™ncia:
            
            *   **Detec√ß√£o de Comunidades (M√©todo de Louvain):** Este algoritmo identifica automaticamente "bairros" ou "panelinhas" de vendedores que est√£o mais conectados entre si do que com o resto da rede. O resultado s√£o as features:
                - `grafo_comunidade_id`: O ID do "bairro" do vendedor
                - `grafo_taxa_suspeita_comunidade`: A "toxicidade" do bairro, ou seja, a porcentagem de produtos suspeitos dentro daquela comunidade
            
            *   **An√°lise de Centralidade (Identificando Atores Chave):** Usamos diferentes m√©tricas para medir a import√¢ncia de um vendedor na rede:
                - **`grafo_pagerank`:** O famoso algoritmo do Google, aqui adaptado para medir a **influ√™ncia** de um vendedor. Um vendedor √© influente se ele est√° conectado a outros vendedores que tamb√©m s√£o influentes. Ajuda a encontrar os "centros gravitacionais" da rede
                - **`grafo_betweenness`:** Mede a import√¢ncia de um vendedor como uma **"ponte"** entre diferentes grupos. Vendedores com `betweenness` alta podem ser distribuidores que conectam diferentes c√©lulas de fraude
                - **`grafo_closeness`:** Mede a **proximidade** de um vendedor a todos os outros. Um valor alto indica que o vendedor pode espalhar informa√ß√µes (ou produtos fraudulentos) rapidamente pela rede
            
            **4. L√≥gica de Detec√ß√£o:**
            
            - O sistema sinaliza vendedores que, mesmo parecendo leg√≠timos individualmente, pertencem a comunidades com alta taxa de suspeita
            - Ele prioriza a investiga√ß√£o de vendedores com alta centralidade (alto PageRank ou Betweenness) que tamb√©m exibem comportamento suspeito
            - Os padr√µes revelados pelo grafo nos permitem identificar opera√ß√µes coordenadas que seriam invis√≠veis em uma an√°lise an√∫ncio por an√∫ncio
            
            **Vantagens:**
            
            - Detecta fraudes coordenadas e em rede
            - Identifica os vendedores "chefes" ou "distribuidores" de uma opera√ß√£o
            - Complementa a an√°lise individual com o poderoso contexto da rede social do vendedor
            """)

# --- RESUMO EXECUTIVO ---
st.header("üìã Resumo Executivo")

col1, col2, col3 = st.columns(3)

with col1:
    st.metric("An√∫ncios de Alto Risco", f"{(df['risk_category'] == 'Cr√≠tico').sum()}", "Cr√≠tico")
    st.metric("An√∫ncios de Risco Alto", f"{(df['risk_category'] == 'Alto').sum()}", "Alto")

with col2:
    st.metric("Vendedores com 100% Suspeitos", f"{(seller_metrics['taxa_suspeita'] == 100).sum()}", "Cr√≠tico")
    st.metric("Vendedores com >50% Suspeitos", f"{(seller_metrics['taxa_suspeita'] > 50).sum()}", "Alto")

with col3:
    if 'preco_atual' in df.columns:
        preco_medio_suspeitos = df[df['is_fraud_suspect_v2'] == 1]['preco_atual'].mean()
        preco_medio_legitimos = df[df['is_fraud_suspect_v2'] == 0]['preco_atual'].mean()
        st.metric("Pre√ßo M√©dio Suspeitos", f"R$ {preco_medio_suspeitos:.0f}")
        st.metric("Pre√ßo M√©dio Leg√≠timos", f"R$ {preco_medio_legitimos:.0f}")

# --- SIDEBAR ---
# Logo HP no topo da sidebar (acima das abas de navega√ß√£o) - Centralizado
col1, col2, col3 = st.sidebar.columns([1, 2, 1])
with col2:
    st.image(get_logo_path(), width=150)

st.sidebar.success("üéØ Voc√™ est√° na p√°gina Dashboard Geral")
st.sidebar.info("""
**Navega√ß√£o:**
- üìä Dashboard Geral (atual)
- üî¨ Investiga√ß√£o de An√∫ncios
- üë• An√°lise de Vendedores
- üï∏Ô∏è Rede de Fraude
- üîç Extrair e Analisar An√∫ncio
""")

st.sidebar.metric("√öltima Atualiza√ß√£o", "Agora", "Tempo real")
